/*
编写一个程序，将输入字符串中的字符按如下规则排序。

规则 1 ：英文字母从 A 到 Z 排列，不区分大小写。

如，输入： Type 输出： epTy

规则 2 ：同一个英文字母的大小写同时存在时，按照输入顺序排列。

如，输入： BabA 输出： aABb

规则 3 ：非英文字母的其它字符保持原来的位置。


如，输入： By?e 输出： Be?y

*/
/*
共有26个字母所以最外层的循环是26，每次循环从字符串中只选择一个字母并如栈，
这样经过26次循环字符串中a-z就按顺序入栈了，再从头到尾输出即可了

遍历26遍，第一遍将源字符串中的’a’和‘A’(如果有)按原输入顺序拿出来放在容器向量中，第二遍将源字符串中的’b’和‘B’(如果有)按原输入顺序拿出来放在容器向量中…….这就完成了规则一和规则二的要求
接下来完成规则三的要求，不要上来就做，先想想有几种可能思路。上来就想到的思路是往容器向量中插入源字符串中的非字母字符。
另一个思路是还是使用源字符串中的非字母字符，将源字符串中的字符字符依次用容器向量中的字符代替
。由于非字母字符的种类远比字符字符的种类（就两种）多，选择简单的分类讨论方法，即用后一种思路。
*/

#include<stdio.h>
#include<string.h>

int main()
{
    char str[1000]={0};
    while(gets(str)){
        char temp[1000]={0};
        int k =0;
        for(int i=0;i<26;i++){
            for(int j=0;j<strlen(str);j++){
                if((str[j]=='a'+i) || (str[j]=='A'+i)){//按顺序入栈
                    temp[k]=str[j];
                    k++;
                }
            }
        }
        int m=0;
        for(int n=0;n<strlen(str);n++){
            if((str[n]>='a'&&str[n]<='z')||(str[n]>='A'&&str[n]<='Z')){
                printf("%c",temp[m++]);//m++; 
                /*只有当向量容器中的字符使用后m才自增，
                //当str[n]非字母时，进入下次循环，n增1 而m不增;    
                //m++先返回m的值完成本次对s[i]的赋值，然后m再增1，等价于{s[i]=tempChar[k];k+=1;}*/
            }
            else {printf("%c",str[n]);}
        }
        printf("\n");
    }
    
    return 0;
    
}
