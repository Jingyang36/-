/*
输入描述:
﻿一组输入整数序列I和一组规则整数序列R，I和R序列的第一个整数为序列的个数（个数不包含第一个整数）；整数范围为0~0xFFFFFFFF，序列个数不限

输出描述:
﻿从R依次中取出R<i>，对I进行处理，找到满足条件的I： 

I整数对应的数字需要连续包含R<i>对应的数字。比如R<i>为23，I为231，那么I包含了R<i>，条件满足 。 

按R<i>从小到大的顺序:

(1)先输出R<i>； 

(2)再输出满足条件的I的个数； 

(3)然后输出满足条件的I在I序列中的位置索引(从0开始)； 

(4)最后再输出I。 

附加条件： 

(1)R<i>需要从小到大排序。相同的R<i>只需要输出索引小的以及满足条件的I，索引大的需要过滤掉 

(2)如果没有满足条件的I，对应的R<i>不用输出 

(3)最后需要在输出序列的第一个整数位置记录后续整数序列的个数(不包含“个数”本身)

 

序列I：15,123,456,786,453,46,7,5,3,665,453456,745,456,786,453,123（第一个15表明后续有15个整数） 

序列R：5,6,3,6,3,0（第一个5表明后续有5个整数） 

输出：30, 3,6,0,123,3,453,7,3,9,453456,13,453,14,123,6,7,1,456,2,786,4,46,8,665,9,453456,11,456,12,786

说明：

30----后续有30个整数

3----从小到大排序，第一个R<i>为0，但没有满足条件的I，不输出0，而下一个R<i>是3

6--- 存在6个包含3的I 

0--- 123所在的原序号为0 

123--- 123包含3，满足条件 

将规则数组排序(从小到大)，并去重。

遍历输入数组，检查输入数组的每个元素是是否包含规则数组中的数字i,如果包含则将输入数组元素位置和元素输出到最终结果中。

*/

#include <stdio.h>
#include <string.h>

int main() {
	int I[1000] = { 0 }, R[1000] = { 0 };
	int i, j, tmp, cnt, cnt_t, CNT_T[1000] = { 0 }, CNT[1000] = { 0 };
	char tmp1[20] = { 0 }, tmp2[20] = { 0 };
	while (scanf("%d", &I[0]) != EOF) {
		for (i = 1; i <= I[0]; i++)
			scanf("%d", &I[i]);
		scanf("%d", &R[0]);
		for (i = 1; i <= R[0]; i++)
			scanf("%d", &R[i]);
		//R数组排序
		for (i = 1; i<R[0]; i++) {
			for (j = 1; j<R[0] - (i - 1); j++) {
				if (R[j]>R[j + 1]) {
					tmp = R[j];
					R[j] = R[j + 1];
					R[j + 1] = tmp;
				}
			}
		}
		//R数组去重
		for (i = 1; i<R[0];) {
			if (R[i] == R[i + 1]) {
				for (j = i + 1; j<R[0]; j++)
					R[j] = R[j + 1];
				R[0]--;
			}
			else
				i++;
		}
		//把数字转换成字符串，使用strstr函数可以快捷判别是否有子串
		for (i = 1, cnt = 1; i <= R[0]; i++) {//cnt=0,用于存放总的个数
			sprintf(tmp1, "%d\0", R[i]);//把R[I]中的数字传到双引号之中，并赋给字符串tmp1
			for (j = 1, cnt_t = 0; j <= I[0]; j++) {
				sprintf(tmp2, "%d\0", I[j]);
				if (strstr(tmp2, tmp1)) {//如果满足，把I的序号和数值放到CNT_T中
					CNT_T[cnt_t++] = j - 1;
					CNT_T[cnt_t++] = I[j];
				}
			}
			if (cnt_t != 0) {//把R[i]中符合的情况，先把R[i]数值保存，再保存个数，再把CNT_T中相应的成对元素放到CNT中
				CNT[cnt++] = R[i];
				CNT[cnt++] = cnt_t / 2;
				for (j = 0; j<cnt_t; j++) {
					CNT[cnt++] = CNT_T[j];
				}
			}
		}
		CNT[0] = cnt - 1;
		for (i = 0; i<cnt - 1; i++)
			printf("%d ", CNT[i]);
		printf("%d\n", CNT[i]);
	}
	return 0;
}
